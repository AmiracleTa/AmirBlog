---
title: 浅谈最短路和差分约束
date: 2025-12-13 00:24:21
updated: 2025-12-15 05:32:10
tags:
  - XCPC
  - 差分约束
  - 最短路
  - SPFA
  - Bellman-Ford
cover: https://cdn.amiracle.site/nya~%20.png
---

## 差分约束系统

$n$ 个未知量 ${x_1,\; x_2 \; \cdots \; x_n}$，$m$ 个不等式条件
$$
\begin{cases}
x_{i_1} - x_{j_1} \le c_1 \\
x_{i_2} - x_{j_2} \le c_2 \\
\vdots \\
x_{i_m} - x_{j_m} \le c_m
\end{cases}
$$
这样的一组不等式就是一个差分约束系统，差分约束系统的求解可以巧妙的转化为最短路问题

## 和最短路的关系

先移项，得到 {% span blue, $x_i \le x_j + c$ %}，可以发现和最短路中的三角不等式非常相似，{% span blue, $dis_u \le dis_v + w$ %}。因而可以转化成最短路问题，具体来说，先对不等式建图，每个不等式都可看成边，让 $j$ 向 $i$ 连一条权为 $c$ 的边，此图上跑最短路，得到的 $dis_i$ 就是一组满足条件的解。

### 转化的充要性证明

限制条件转化为有向边，跑最短路得到的 $dis$ 满足 {% span blue, $dis_u \le dis_v + c$ %}，把 $dis_u,\; dis_v$ 看成 $x_u,\; x_v$ 的话，也就是 {% span blue, $x_u \le x_v + c$ %}，因而当最短路有解，也就是没有负环，原不等式就有解，且解就为 $dis$，**必要性成立**

思考一下变量关系，若是关系无环比如说是一条链，容易想到，此时的不等式和最短路都是有解的。若是变量关系成环，设存在一个有向环 {% span blue, $v_0 \to v_1 \to \cdots \to v_{k-1} \to v_0$ %}，对应的边权依次为 {% span blue, $c_0$，$c_1$，$\cdots$，$c_{k-1}$ %}。

由每条边对应的约束，有
$$
\begin{cases}
x_{v_1} \le x_{v_0} + c_0, \\
x_{v_2} \le x_{v_1} + c_1, \\
\;\vdots \\
x_{v_0} \le x_{v_{k-1}} + c_{k-1}.
\end{cases}
$$
将上述不等式逐项代入相消可得
$$
x_{v_0} \le x_{v_0} + \sum_{t=0}^{k-1}c_t
$$
若不等式组有解，则必有
$$
\sum_{t=0}^{k-1}c_t \ge 0
$$
否则会出现矛盾，而这也意味着图中不存在负环，所以此时最短路也是有解的，**充分性成立**

{% p bold, 因此，不等式组有解等价于图中的最短路有解，这个转化是充分且必要的 %}

### 最小解和最大解

若是 {% span blue, $x_v \le x_u + c$ %}，这样从 $u$ 跑到 $v$ ，得到 {% span blue, $dis_v = dis_u + c$ %}，可以发现 $x_v$ 的解正好取等，即最大解，也可推出其他变量的解都为最大解。若我们想要最小解，那么让 {% span blue, $x_v \ge x_u + c$ %}，这样从 $u$ 跑到 $v$，不就有最小解了吗。但是，这样还是跑最短路吗？再观察 {% span blue, $x_v \ge x_u + c$ %}，回想一下我们前面的证明，可以发现最短路的关键性质，{% span blue, $dis_v \le dis_u + c$ %}，和此不等式不再契合。然而有没有什么满足 {% span blue, $dis_v \ge dis_u + c$ %} 这个性质呢？仔细一看，这不正是最长路的性质吗，对的，我们直接跑最长路就可以了，相似的，无解条件为存在正环

{% p bold, 因此，$x_v \le x_u + c$ 这样 ${u \to v}$ 建边跑最短路能得到最大解，$x_v \ge x_u + c$ 这样 ${u \to v}$ 建边跑最长路能得到最小解 %}

## 负权图最短路

有负权边后，dijkstra 就不再适用了，因为 dijkstra 基于贪心思想，每走一步期望的 dis 都应该是单调不减的。所以我们需要可以在负权图上跑最 短/长 路，且能判 负/正 环的算法

### Bellman-Ford $O(n \cdot m)$

此算法暴力的进行 $n - 1$ 轮，每轮都从所有的点向所有方向走，这样最短路一定可以延展出来，因为一条简单路最多 $n - 1$ 条边嘛。正是因为它非常之暴力，所以能处理 $dijkstra$ 处理不了的负权问题。还能检测负环，可以额外跑一轮，若还有 $dis$ 可以更新的话，那只能是存在负环了

**MYCODE**

```cpp

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;

constexpr ll inf = 1e18;

void solve(){
    int n, m;
    cin >> n >> m;
    vector<vector<pii>> gra(n + 1);
    for(int i=1; i<=m; i++){
        int u, v, w;
        cin >> u >> v >> w;
        if(w >= 0){
            gra[u].push_back({v, w});
            gra[v].push_back({u, w});
        }
        else gra[u].push_back({v, w});
    }

    vector<ll> dis(n + 1, inf);
    dis[1] = 0;
    for(int k=0; k<n-1; k++){ // 尝试 n - 1 轮松弛
        for(int i=1; i<=n; i++){
            if(dis[i] == inf) continue;
            for(auto [v, w] : gra[i]){
                dis[v] = min(dis[v], dis[i] + w);
            }
        }
    }

    bool neg = false; // 额外跑一轮 // neg 为 ture 则存在负环
    for(int i=1; i<=n; i++){
        if(dis[i] == inf) continue;
        for(auto [v, w] : gra[i]){
            neg |= dis[i]+w < dis[v];
        }
    }
    
    cout << (neg? "YES":"NO") << '\n';
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; cin >> t;
    while(t--) solve();
    
    return 0;
}
```

### SPFA $O(k \cdot m)$

在 $Bellman$-$Ford$ 中，最短路还没延展到的点的遍历是多余的。所以可以用一个队列，存已经延展的点，从这些点去扩展。$spfa$ 非常类似换掉 $pq$ 的 $dijkstra$，它是 $Bellman$-$Ford$ 算法的队列优化版，复杂度为 $O(k \cdot m)$ ~ $O(n \cdot m)$。此外，也有启发式的 $spfa$，不过比较玄学，启发的大致思想是，更容易松弛别人的点就放队列前，在此不过多赘述

**MYCODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;

constexpr ll inf = 1e18;

void solve(){
    int n, m;
    cin >> n >> m;
    vector<vector<pii>> gra(n + 1);
    for(int i=1; i<=m; i++){
        int u, v, w;
        cin >> u >> v >> w;
        if(w >= 0){
            gra[u].push_back({v, w});
            gra[v].push_back({u, w});
        }
        else gra[u].push_back({v, w});
    }

    bool neg = false;
    int s = 1; // 源点 // 可能要建超级源点
    vector<bool> inq(n + 1);
    vector<int> cnt(n + 1); // 当前到 u 的最短路的边数
    vector<ll> dis(n + 1, inf);
    dis[s] = 0, inq[s] = true;
    queue<int> q;
    q.push(s);
    while(!q.empty() && !neg){
        int u = q.front(); q.pop();
        inq[u] = false;
        for(auto [v, w] : gra[u]){
            if(dis[u] + w < dis[v]){
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1;
                if(!inq[v]) q.push(v), inq[v]=true;
                if(cnt[v] >= n){
                    neg = true;
                    break;
                }
            }
        }
    }
    
    cout << (neg? "YES":"NO") << '\n';
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; cin >> t;
    while(t--) solve();
    
    return 0;
}
```

题目链接: [【模板】负环](https://www.luogu.com.cn/problem/P3385)

## 差分约束例题

### [【模板】差分约束](https://www.luogu.com.cn/problem/P5960)

我们先建一个超级源点 s，其对所有点建一条权为 0 的边，主要目的是让图连通，方便处理，也相当于加了限制条件 {% span blue, $x_i - 0 \le x_s$ %}，而且这样操作是不影响可解性的，因为若有解，则整体平移后也是一个解。建好图，从 s 开始跑一下最短路就可以了。

{% note info modern%}

注意 : 加源点后图中就是 $n + 1$ 个节点了 , 要判断 $cnt[v] \ge n+1$

{% endnote %}

**MYCODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;

constexpr ll inf = 3e18;

// 差分约束 就是 负权图最短路
void solve(){
    int n, m;
    cin >> n >> m;
    vector<vector<pii>> gra(n + 1);
    for(int i=1; i<=m; i++){
        int u, v, w;
        cin >> v >> u >> w;
        gra[u].push_back({v, w});
    }
    for(int i=1; i<=n; i++){
        gra[0].push_back({i, 0});
    }

    bool neg = false;
    int s = 0;
    vector<bool> inq(n + 1);
    vector<int> cnt(n + 1);
    vector<ll> dis(n + 1, inf);
    dis[s] = 0, inq[s] = true;
    queue<int> q;
    q.push(s);
    while(!q.empty() && !neg){
        int u = q.front(); q.pop();
        inq[u] = false;
        for(auto [v, w] : gra[u]){
            if(dis[u] + w < dis[v]){
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1;

                if(!inq[v]) q.push(v), inq[v]=true;

                if(cnt[v] >= n+1){ // 有源点, 所以是 n+1 !
                    neg = true;
                    break;
                }
            }
        }
    }
    if(neg){
        cout << "NO" << '\n';
        return;
    }

    for(int i=1; i<=n; i++){
        cout << dis[i] << " \n"[i == n];
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; //cin >> t;
    while(t--) solve();
    
    return 0;
}
```

### [SP116 - Intervals](https://www.luogu.com.cn/problem/SP116)

#### **题意**

$n$ 个区间 $[a_i, b_i]$，每个区间至少选 $c_i$ 个整数。满足这 $n$ 条限制的情况下，至少要取多少个整数

#### **解析**

每条限制可转化成 {% span blue, $pre_{b_i} - pre_{a_i-1} \ge c_i$ %}，很容易想到差分约束。关键是如何建图去描述这个问题，思考 $pre$ 数组的特点，大概为 {% span blue, $pre_0 = 0$，$0 \le pre_{i-1} - pre_i \le 1$ %}，这两个条件已经足够描述出合法的前缀和数组，我们将此额外限制加入图中，这样就可以得到合法的解

整理一下 :
$$
\begin{cases}
pre_{b_i} \ge pre_{a_i - 1} + c_i \\
pre_0 = 0 \\
pre_i \ge pre_{i-1} - 1 \\
pre_{i-1} \ge pre_i
\end{cases}
$$
这题需要求最小解，我们要跑最长路。此外，这题值域有 0，我们简单平移一下即可

#### **MYCODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;

constexpr ll inf = 1e18;

// 差分约束 , 最长路 , 求最小解
/*
  好像不需要判正环

*/
const int MX = 5e4+1;
void solve(){
    int n; cin >> n;
    vector<vector<pii>> gra(MX + 1);
    for(int i=1; i<=n; i++){
        int u, v, c;
        cin >> u >> v >> c;
        u++, v++, c;
        gra[u-1].push_back({v, c});
    }
    for(int i=1; i<=MX; i++){
        gra[i-1].push_back({i, 0}); // 0 <= pi - pi-1 <= 1 // 两者都要
        gra[i].push_back({i-1, -1});
    }

    int s = 0;
    vector<bool> inq(MX + 1);
    vector<ll> dis(MX + 1, -inf);
    dis[s] = 0, inq[s] = true;
    queue<int> q;
    q.push(s);
    while(!q.empty()){
        int u = q.front(); q.pop();
        inq[u] = false;
        for(auto [v, w] : gra[u]){
            if(dis[u] + w > dis[v]){ // 改这里即为最长路
                dis[v] = dis[u] + w;

                if(!inq[v]) q.push(v);

                inq[v] = true;
            }
        }
    }
    cout << dis[MX] << '\n';
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; cin >> t;
    while(t--) solve();
    
    return 0;
}
```

### [A - 2019 CCPC Harbin](https://codeforces.com/gym/102394/problem/A)

和上面那道题比较相似，但多了一个二分，限制条件要想好，注意 spfa 中的剪枝，否则会 tle

#### **题意**

n 个立方体一排，涂色，有两种限制，分别有 ${M_1}$，${M_2}$ 个。第一种：${[L_i, \; R_i]}$ 中的立方体涂色个数 ${\ge k}$，第二种：${[L_i,\; R_i]}$ 外的立方体涂色个数 ${\ge k}$。求满足限制的最小染色立方体数

${(n \le 3000,0\le M_1,M_2 \le 3000)}$

#### **解析**

和上面的题比较相似。不同点在于限制二是 {% span blue, ${pre_n - pre_r + pre_{l-1} \ge k}$ %}，多一个变量，容易想到二分 $pre_n$ 去掉一个变量，这样就转化成了差分约束问题。我们二分 ${pre_n}$，{% span blue, 将 ${pre_n}$ 设为 ${mid}$ %}，因为前缀和的性质，我们还有 {% span blue, ${pre_0 = 0}$，${0 \le pre_{i-1} - pre_i \le 1}$ %}。

限制条件即为 :
$$
\begin{cases}
pre_0 = 0 \\
pre_n = mid \\
pre_i \ge pre_{i-1} - 1 \\
pre_{i-1} \ge pre_i
\end{cases}
$$
要注意的是，为了解的正确性，我们至少将所有的限制边都遍历过一遍，而此题仅从超级源点出发不是很能保证满足这个条件。因为 {% span blue, ${x_s=0}$ %} 而 {% span blue, $pre_n = mid$ %}，可能会有 {% span blue, ${x_s + 0 < pre_n}$ %}，这导致点 n 不会入队，也就会使得点 $n$ 相关的限制边没有遍历到，从而导致错解。解决办法为，不建超级源点 s，而是直接将每个点都加入队列中，这样一定可以保证每个限制边都遍历过

{% p bold, 另，此人竟然提交了惊人的 77 发之后 ? ? 终于算是过掉了这题 ? ? QAQ %}

![](https://cdn.amiracle.site/77%E5%8F%91!!.png)

~~( 这人也太菜了，我无言以对 )~~

#### **MYCODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;

constexpr ll inf = 3e18;

// 差分约束 , 最长路 , 求最小解
/*
  单调性 
  pn 越大 , 条件越宽松 , 更容易有解
  容易证明, 无解有解对应的 pn 区间连续

*/

void solve(){
    int n, m1, m2;
    cin >> n >> m1 >> m2;
    vector<tuple<int, int, int>> q1(m1), q2(m2);
    for(auto& [l, r, c] : q1) cin >> l >> r >> c;
    for(auto& [l, r, c] : q2) cin >> l >> r >> c;

    vector<bool> inq(n + 1);
    vector<int> cnt(n + 1);
    vector<ll> dis(n + 1, -inf);
    vector<vector<pii>> gra(n + 1);

    auto check = [&](int pn){
        inq.assign(n+1, 0), cnt.assign(n+1, 0), dis.assign(n+1, -inf);
        for(int i=0; i<=n; i++) gra[i].clear(); // [0, n+1]

        for(auto [l, r, c] : q1){
            gra[l-1].push_back({r, c});
        }
        for(auto [l, r, c] : q2){
            gra[r].push_back({l-1, c-pn});
        }
        for(int i=1; i<=n; i++){
            gra[i-1].push_back({i, 0}); // 0 <= pi - pi-1 <= 1 // 两者都要
            gra[i].push_back({i-1, -1});
        }

        queue<int> q;
        for(int i=0; i<=n; i++) q.push(i), inq[i] = true; // 保证所有的限制边都遍历到
        dis[0] = 0, dis[n] = pn; // 设定 p0 = 0 // 二分了 pn , 这里要保持一致
        while(!q.empty()){
            int u = q.front(); q.pop();
            inq[u] = false;
            
            // while 中直接剪枝
            if(u == 0 && dis[u] > 0) return false;
            if(u == n && dis[u] > pn) return false;

            for(auto [v, w] : gra[u]){
                if(dis[u] + w > dis[v]){
                    dis[v] = dis[u] + w;
                    cnt[v] = cnt[u] + 1;

                    if(!inq[v]) q.push(v), inq[v] = true;

                    if(cnt[v] >= n+1) return false; // 因为是 n+1 个点啊
                }
            }
        }
        return true;
    };
    
    int lo = -1, hi = n+1;
    while(lo + 1 != hi){
        int mid = lo + hi >> 1;
        if(check(mid)) hi = mid;
        else lo = mid;
    }
    cout << hi << '\n';
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; cin >> t;
    while(t--) solve();
    
    return 0;
}
```

---

{% note info modern %}

**此外**：{% span blue, $\frac{x_i}{y_i} \le c_i$ %}，也可以转化成差分约束系统，两边取 $\log$ 即可

{% endnote %}

{% p bold, 此篇完结. %}
