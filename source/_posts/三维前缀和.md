---
title: 三维前缀和
date: 2025-09-02 19:43:55
updated: 2025-09-02
tags:
  - XCPC
categories: XCPC
cover: https://cdn.amiracle.site/%E6%98%9F%E3%81%A8%E5%B0%91%E5%A5%B3.jpg
---

二维前缀和是一维前缀和的扩展，三维前缀和则是二维的基础上再加一维

# 三维前缀和

求三维前缀和数组，可以分别对 x，y，z 维进行求和。二维同样也可以分别对 x，y 维进行求和，只是我们很少这样去做。

具体来说 : 

```cpp
for(int i=1; i<=n; i++)
for(int j=1; j<=m; j++)
for(int k=1; k<=h; k++)
mat[i][j][k] += mat[i-1][j][k];

for(int i=1; i<=n; i++)
for(int j=1; j<=m; j++)
for(int k=1; k<=h; k++)
mat[i][j][k] += mat[i][j-1][k];

for(int i=1; i<=n; i++)
for(int j=1; j<=m; j++)
for(int k=1; k<=h; k++)
mat[i][j][k] += mat[i][j][k-1];
```

还有一种容斥的方法也可以求这个，不过比较复杂 : 

```cpp
sum[i][j][k] = 
    +a[i][j][k]

    +sum[i-1][j][k]
    +sum[i][j-1][k]
    +sum[i][j][k-1]

    -sum[i-1][j-1][k]
    -sum[i-1][j][k-1]
    -sum[i][j-1][k-1]

    +sum[i-1][j-1][k-1]
```



# 求子三维数组的和

求 ${[x_1, x_2] \times [y_1, y_2] \times [z_1, z_2]}$ 这个矩形题的和，需要用到容斥定理，可以画图去理解。

```cpp
sum[x1...x2][y1...y2][z1...z2] =
    +sum[x2][y2][z2]

    -sum[x1-1][y2][z2]
    -sum[x2][y1-1][z2]
    -sum[x2][y2][z1-1]

    +sum[x1-1][y1-1][z2]
    +sum[x1-1][y2][z1-1]
    +sum[x2][y1-1][z1-1]

    -sum[x1-1][y1-1][z1-1]
```



# B-Chengdu ICPC 2024

**题意 :** 

有 3 种服装，同种服装完全相同，要将这 3 种服装分配给 $n$ 个人，有些人已有服装无需分配，且要求相邻两个人的服装不能相同。每次询问给定 3 种服装数量 $x$，$y$，$z$，问有多少种分配方式？

${(0 \le x,y,z \le 300, n \le 300, Q\le1e5)}$

**解析 :** 

因为 x，y，z 比较小，我们可以直接预处理出来所有 x，y，z 的情况数，这个 dp 很好去求。

定义 dp[x\][y\][z\] -> 3 种服装恰好用了 x, y, z 套。然后简单转移一下就好。

方案数则为三维前缀和 ${\sum dp_{i\le x, j \le y, k \le z}}$ 

##### **MYCODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int inf = 0x3f3f3f3f;
const int mo = 1e9 + 7;
const int MX = 301;

ll dp[MX][MX][MX][3];
ll f[MX][MX][MX];
int inv2 = (mo + 1) / 2;

void add(auto& x, auto y){
    x = (x + y) % mo;
}

void solve(){
    int n, q;
    cin >> n >> q;
    string s;
    cin >> s;
    s = "x" + s;

    dp[0][0][0][0] = dp[0][0][0][1] = dp[0][0][0][2] = 1;
    for(int i=0; i<=300; i++)
    for(int j=0; j<=300; j++)
    for(int k=0; k<=300; k++)
    for(int o=0; o<3; o++){
        int pos = i + j + k;
        if(pos > n) continue;
        if(o != 0 && i && (s[pos]=='?' || s[pos]=='a')) add(dp[i][j][k][0], dp[i-1][j][k][o]);
        if(o != 1 && j && (s[pos]=='?' || s[pos]=='b')) add(dp[i][j][k][1], dp[i][j-1][k][o]);
        if(o != 2 && k && (s[pos]=='?' || s[pos]=='c')) add(dp[i][j][k][2], dp[i][j][k-1][o]);
    }

    int na = count(s.begin(), s.end(), 'a');
    int nb = count(s.begin(), s.end(), 'b');
    int nc = count(s.begin(), s.end(), 'c');

    for(int i=na; i<=300; i++)
    for(int j=nb; j<=300; j++)
    for(int k=nc; k<=300; k++)
    for(int o=0; o<3; o++) if(i + j + k == n){
        f[i-na][j-nb][k-nc] += dp[i][j][k][o];
    }

    for(int j=0; j<=300; j++)
    for(int k=0; k<=300; k++)
    for(int i=1; i<=300; i++)
    add(f[i][j][k], f[i-1][j][k]);

    for(int i=0; i<=300; i++)
    for(int k=0; k<=300; k++)
    for(int j=1; j<=300; j++)
    add(f[i][j][k], f[i][j-1][k]);

    for(int i=0; i<=300; i++)
    for(int j=0; j<=300; j++)
    for(int k=1; k<=300; k++)
    add(f[i][j][k], f[i][j][k-1]);

    for(int i=0; i<q; i++){
        int x, y, z;
        cin >> x >> y >> z;
        cout << f[x][y][z]*inv2%mo << '\n';
    }

}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; // cin >> t;
    while(t--) solve();
    
    return 0;
}
```

#### 题目链接 : [B - Chengdu ICPC 2024](https://codeforces.com/gym/105486/problem/B)

