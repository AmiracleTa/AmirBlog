---
title: 区域赛铜牌题题单寒假纪
tags: XCPC
date: 2026-02-01 20:13:41
cover: https://cdn.amiracle.site/ATRI.png
---

### **前言**

刷刷某大佬整理的[**区域赛铜牌题题单**](https://vjudge.net/contest/758960) *(十分之感谢!)*

记录一下，顺便梳理思路

## BA - BZ

### BA - The Only Way to the Destination

#### **难度: 2.5**

问，任意两方块是否有唯一的简单路径。

#### **思路**

首先特判 n = 1 的情况，一定满足，一开始忘判了

n >= 2，发现存在 ${2 \times 2}$ 的方格就不能满足条件，而由于墙的列数不会很多${(k\le 1e5)}$，所以 ${m \le 1e9}$ 其实是诈骗，m > 3k 就肯定会有并列的两个空行，一定无法满足条件。此外，可以想象，若存在某个墙组成的连通块不和边界相连，则一定是因为某个路径将其包围，形成了一个环，这种情况一定不满足。

若合法，则一定有 ${m < 3k}$，于是我们可以枚举列，判断是否存在 ${2 \times 2}$ 的情况。判断墙是否和边界连通，可以对墙建图后 dfs

整体感觉不是很好写，比较考验码力

另外还要注意，墙是 8 连通而不是 4 连通

#### **MYCODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

constexpr int inf = 0x3f3f3f3f;

void solve(){
    int n, m, k;
    cin >> n >> m >> k;

// 边界
    if(n == 1){
        int x; while(cin>>x);
        cout << "YES" << '\n';
        return;
    }
    if(m > 3*k){
        int x; while(cin>>x);
        cout << "NO" << '\n';
        return;
    }

    vector<vector<pii>> col(m + 2);
    for(int i=1; i<=k; i++){
        int l, r, y;
        cin >> l >> r >> y;
        col[y].push_back({l, r});
    }
    col[0].push_back({1, n});
    col[m+1].push_back({1, n});
    for(int i=0; i<=m+1; i++){
        col[i].push_back({0, 0});
        col[i].push_back({n+1, n+1});
        sort(col[i].begin(), col[i].end());
    }
    bool ok = true;
    for(int i=1; i<=m; i++){
        int p1 = 1, p2 = 1;
        while(p1 < col[i-1].size()){ // (l, r) 左右都开, 边界需要处理一下
            while(p2 < col[i].size()-1 && col[i-1][p1-1].second+1 > col[i][p2].first-1) p2++;
            while(p2 < col[i].size() && col[i-1][p1].first-1 >= col[i][p2-1].second+1){
                int l = max(col[i-1][p1-1].second+1, col[i][p2-1].second+1);
                int r = min(col[i-1][p1].first-1, col[i][p2].first-1);
                if(r - l + 1 > 1) ok = false;
                p2++;
            }
            p2--;
            p1++;
        }
    }

    // 连通性判的不对 , 还是不对 , 墙是八连通
    map<pii, int> idx; // {i, p}
    vector<vector<int>> gra(k + 1);
    int tot = 0;
    for(int i=1; i<=m; i++){
        for(int j=1; j<col[i].size()-1; j++){
            idx[{i, j}] = ++tot;
        }
    }
    for(int i=2; i<=m; i++){
        int p = 1;
        for(int j=1; j<col[i].size()-1; j++){
            auto [l, r] = col[i][j];
            while(col[i-1][p].second+1 < l) p++;
            while(p < col[i-1].size()-1 && col[i-1][p].first-1 <= r){
                int u = idx[{i, j}], v = idx[{i-1, p}];
                // cout << u << ' ' << v << endl; // 
                gra[u].push_back(v);
                gra[v].push_back(u);
                p++;
            }
            p--;
        }
    }
    for(int i=1; i<=m; i++){
        for(int j=2; j<col[i].size()-1; j++){
            if(col[i][j-1].second+1 == col[i][j].first){
                int u = idx[{i, j}], v = idx[{i, j-1}];
                gra[u].push_back(v);
                gra[v].push_back(u);
            }
        }
    }
    vector<bool> vis(k + 1);
    auto dfs = [&](auto&& self, int u) ->void {
        if(vis[u]) return;
        vis[u] = true;
        for(int v : gra[u]){
            self(self, v);
        }
    };
    vector<int> a;
    for(int i=1; i<col[1].size()-1; i++) a.push_back(idx[{1, i}]);
    for(int i=1; i<col[m].size()-1; i++) a.push_back(idx[{m, i}]);
    for(int i=1; i<=m; i++){
        for(int j=1; j<col[i].size()-1; j++){
            auto[l, r] = col[i][j];
            if(l == 1 || r == n){
                a.push_back({idx[{i, j}]});
            }
        }
    }
    for(auto u : a){
        dfs(dfs, u);
    }
    // cout << count(vis.begin()+1, vis.end(), true) << endl;
    ok &= (count(vis.begin()+1, vis.end(), true) == k);    
    cout << (ok? "YES":"NO") << '\n';
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; //cin >> t;
    while(t--) solve();
    
    return 0;
}
```

### BB - Gene

怎么说呢，完全没思路，直接看答案了

#### **难度: ?**

q 次询问, 每次给你字符串 t，若 x 为 si 和 t 字符不相同的位置个数，问有几个 s 满足 ${x \le k}$

(1 ≤ N, Q ≤ 300, 1 ≤ M ≤ 60, 000,1 ≤ K ≤ 10)
x

#### **思路**

思路还是很好懂的，就是对字母二进制化后用 bitset/ull 进行优化。具体来说是每个字母用 5 位二进制表示 (${2^5 > 26}$)，5 位全相等则这个字符相等，每次可以判断 64 个字符

也可以进行剪枝优化，因为 k 很小，比较容易超过

时间复杂度 ${O(\frac{NQM}{64} \times 5)}$

#### **MYCODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;

constexpr int inf = 0x3f3f3f3f;

// bitset/ull 优化
// 26 - 5bit
void solve(){
    int n, q, m, k;
    cin >> n >> q >> m >> k;

    int z = (m+63) / 64;
    // 第 i 个字符串 , 第 j 位 , 第 k 个字符
    vector<vector<vector<ull>>> bit(n, vector<vector<ull>>(5, vector<ull>(z)));
    for(int i=0; i<n; i++){
        string s; cin >> s;
        int p = 0;
        while(p < m){
            int mask = s[p] - 'a';
            for(int j=0; j<5; j++){
                bit[i][j][p/64] |= (ull)(mask>>j&1) << (p%64);
            }
            p++;
        }
    }
    for(int qq=0; qq<q; qq++){
        string t; cin >> t;
        vector<vector<ull>> cur(5, vector<ull>(z));
        int p = 0;
        while(p < m){
            int mask = t[p] - 'a';
            for(int j=0; j<5; j++){
                cur[j][p/64] |= (ull)(mask>>j&1) << (p%64);
            }
            p++;
        }
        int ans = 0;
        for(int i=0; i<n; i++){
            auto& vec = bit[i];
            int x = 0;
            for(int j=0; j<z; j++){
                ull mask = 0;
                for(int p=0; p<5; p++){
                    mask |= (vec[p][j] ^ cur[p][j]);
                }
                x += __builtin_popcountll(mask);
                // cout << x << endl;
                if(x > k) break;
            }
            if(x > k) continue;
            ans++;
        }
        cout << ans << '\n';
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; //cin >> t;
    while(t--) solve();
    
    return 0;
}
```

### BC - Indeterminate Equation

#### **难度: 2.5**

问 ${a^k - b^k = n}$ 有几个解

${(T \le 10 , n \le 1e18 , 3 \le k \le 64)}$

#### **思路**

分类讨论，可以算出 ${k = 4}$ 时，大概 a = 5e7 时就有 ${a^k - (a-1)^k > 1e18}$，${k > 4}$ 时只会更少，所以可以暴力枚举 b，然后直接计算 a

当 ${k = 3}$ 时，直接枚举 b 不可行。由 ${(a-b)^3 = a^3 - b^3 + 3ab^2 - 3a^2b}$ 可以得到，${(a-b)^3 = n + 3ab^2 - 3a^2b}$，可以发现 a-b 的值是可以枚举的，最多也不会超过 2e6 的级别。令 ${\Delta = a-b}$ 化简可得二元一次方程，${b^2 + \Delta b - \frac{n-\Delta ^ 3}{3\Delta} = 0}$。对称轴两边分别二分即可解出二元一次方程的两根。

#### **MYCODE**
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using pii = pair<int, int>;
using i128 = __int128;

constexpr int inf = 0x3f3f3f3f;

void solve(){
    ll n; int k;
    cin >> n >> k;
    int ans = 0;
    if(k == 3){
        for(i128 i = 1; i * i * i < n; i++){
            if((n - i*i*i) % (3*i)) continue;
            double t = i / (-2);
            auto f = [&](auto x){
                return x*x + i*x - (n-i*i*i) / (3*i);
            };
            bool ok = false;
            {
                double lo = -1e15, hi = t;
                while(hi - lo > 1e-5){
                    double mid = (lo + hi) / 2;
                    if(f(mid) >= 0) lo = mid;
                    else hi = mid; 
                }
                ok |= (f((i128)lo)==0);
            }
            {
                double lo = t, hi = 1e15;
                while(hi - lo > 1e-5){
                    double mid = (lo + hi) / 2;
                    if(f(mid) >= 0) hi = mid;
                    else hi = mid;
                }
                ok |= (f((i128)hi)==0);
            }
            ans += ok;
        }
    }
    else if(k > 3){
        // b = 1
        int x = 2;
        while( 1 ){
            i128 a = 1;
            for(int i=0; i<k; i++){
                if(a > n+1) break;
                a *= x;
            }
            if(a > n+1) break;
            if(a == n+1) ans++;
            x++;
        }
        
        auto check = [&](int base, auto aim){
            i128 a = 1;
            for(int z=0; z<k; z++){
                a *= base;
                if(a >= aim) return true;
            }
            return false;
        };

        // b >= 2
        x = 2;
        {
            int lo = 1, hi = 7e5;
            while(lo + 1 != hi){
                int mid = lo + hi >> 1;
                if(check(mid, n)) hi = mid;
                else lo = mid;
            }
            x = lo;
        }
        i128 a = 1, lst = 1;
        for(int z=0; z<k; z++) a*=x;
        lst = a;
        for(int i=2; i<=700000; i++){
            i128 b = 1;
            for(int z=0; z<k; z++) b*=i;
            while(a < b+n){
                lst = a;
                x++;
                a = 1;
                for(int z=0; z<k; z++) a*=x;
            }
            if(a - lst > n) break;
            ans += (a-b==n);
        }
    }
    cout << ans << '\n';
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; cin >> t;
    while(t--) solve();
    
    return 0;
}
```

#### BD - Rooted Tree

**TO BE CONTINUE...**